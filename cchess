#! /bin/bash 
# /bin/bash #-x
#set -e

# 2017-1-23
# original filename: cchess.term
## cchess: a PGN generator, which run in command line only

### HEAD ###
### define ###


### 1. 程序版本, 日志, 调试, 语言环境相关 ###
APPNAME="cchess"
VERSION="0.1"

# 1.1 是否记录日志
KEEP_LOG=0

## 1.2 调试开关
SHOW_PGN=1  #保存 PGN 对局后, 是否显示 PGN 文件内容；
SHOW_DATETIME=1  #程序开始时是否以 Date, Time 标签形式显示当前时间
SHOW_DEFAULT_FEN=1  #程序开始时是否显示标准开局的 FEN 标签

SHOW_HOWTO=1  #是否显示简单的4位操作代码示例

ENABLE_CFG=0  #是否生成默认的 cchess.cfg 配置文件(功能待开发)

DEBUG=0

## 1.3 读取当前语言环境，是 zh_CN*, zh_TW*, zh_HK*, 还是其它
# 例：LANG=zh_CN.UTF-8 --> CLANG=zh_CN
CLANG=`echo ${LANG%%.*}`


## 1.5
## 见 TAG1553: PGN_NAME_STYLE
PGN_NAME_STYLE="1"

      ### 保存的 PGN 文件名命名规则 (默认采用方案1). 各方案示例:
      # 方案1: 17av0001.pgn (推荐和默认的方案)
      # 方案2: 2017-1231_2359-59-x1x2x3x4x5.pgn
      # 方案3: 17av0001_2017-1231_2359-59.pgn
      # 或者 方案3: 17av0001_2017-1231_2359-59-x1x2x3x4x5.pgn


### 1.8 显示生成的 PGN 对局/棋谱文件的文本编辑器,或者TTY控制台显示时是否
#   带行号显示 (主要用于调试).
#   见 TAG1714: PGN_VIEWMODE, SHOW_HEAD_LINES, SHOW_TAIL_LINES
#    注: 先用 `tput lines` 命令检测当前控制台的总行数, 然后自动把
#    SHOW_HEAD_LINES 和 SHOW_TAIL_LINES 设为总行数的一半,再减1, 如: 40->18
#
#  PGN_VIEWMODE =0: 只显示最前和最后各10行(不带行号)；
#  =1:(默认方案) 与=0类似, 但同时显示行号(用grep -n 实现)
PGN_VIEWMODE=1
declare -i SHOW_HEAD_LINES  SHOW_TAIL_LINES
declare -i MAX_LINES  FILE_LINES



### 2. 程序相关目录, 用户默认的 PGN/FEN 文件保存目录, 以及其它 ###
SHARE_DIR="/usr/local/share/$APPNAME"

CFG_DIR="$HOME/$APPNAME"
#CFG_DIR="$HOME/.config/$APPNAME"

CFG_FILE="$CFG_DIR/$APPNAME.cfg"
LOG="$CFG_DIR/$APPNAME.log"


## for option --uuid (root only! never show in option --help)
ETC_DIR="$SHARE_DIR/etc"
## UUID_FILE="$ETC/UUID"
# 见 _option_uuid ()

#
PGN_DIR="$HOME/$APPNAME/pgn"
FEN_DIR="$HOME/$APPNAME/fen"

### TODO 39: 
## .pgn_index, .fen_index 文件: 用来记录上次的序号已经编到多少数字了
#  每次运行程序,都会读取这个文件
PGN_INDEX="$PGN_DIR/.pgn_index"
FEN_INDEX="$FEN_DIR/.fen_index"


### 3. 棋子走法相关 ###

#
declare -i STEP=1 LOOP=1 TRUN=1

declare -i PAUSED MISS

declare -a piece_die piece_dxy piece_dstep
declare -a piece_miss

# TEXT_MOVE
## 见定义 D1125: TEXT_MOVE: 每步走法的4个字, 如 车五进一


### 内部参数设置,一般不需要调整
# 黑方走法的数字格式: 0代表中文全角数字(默认方案,排版对齐效果好);
# 1: 代表英文半角数字；其它数值: 等同于=0
BLACK_MOVE_FORMAT="0"


## STEP: 红方/黑方任意一方每走一步,计数+1
## LOOP: 第几回合: 红,黑双方各走完一步后, 计数+1(实际是黑方走后+1)
## TRUN: 1=轮到红方走; 0=黑方走. 走完后马上把1变0,0变1

## PAUSED: 上一步对方是否有让先(停走). 1代表停走,0代表正常走棋
## MISS:   之前是否已经让过这个棋子(即确认棋盘上还有没有这个棋子)
#          1代表找不到这个棋子(棋子已让过,或者被吃了)；
#          0代表棋子还在, 或者可以走这步棋
#
# piece_die (数组): 被吃掉的所有棋子, 保存在数组 piece_die 里
#    数组最多31个数值(0-30) . 如果最后一个数值是 K 或者 k
#    表示红帅/黑将被吃,棋局结束.(棋盘上至少还有最后一个帅或将)
#
#    数组里的棋子定义示例:
#    K(大写,红帅), k(小写,黑将), R8(红:八路车), r8(黑:8路车)
#    这记录了棋子的原始位置, 用来跟踪每个棋子的完整走子路线.
#    如果某个棋子如 R8(红车八)走棋后,在其它的位置被吃掉,写进
#    piece_die 数组的代码仍然应该记作R8
#
# piece_dxy (数组): 依次记录被吃掉的棋子的坐标(ICCS坐标格式)；
#     如: a0(红左车默认位置), i0(红右车默认位置),
#        a9(黑1路车默认位置), i9(黑9路车默认位置)；
#
# piece_dstep (数组):  依次记录棋子被是在第几步被吃掉的
#        (对应STEP变量,即从1开始的整数)；
#
#  注: 如果有吃子, 三个数组 piece_die, piece_dxy, piece_dstep 应同时更新
#    数组的索引也是同步对应, 不能错位；
#
# piece_miss (数组): 依次记录开局时被让掉的棋子. 数值规则与数组 piece_die 相同


### 4. 棋子坐标相关 ###
#
## 定义 FEN 数据和棋盘上各点位的棋子数组.
## 参照中国象棋 ICCS 坐标格式执行
#  顺序: 每一行(从上到下, 即从黑方底线到红方底线, 数组9到数组0. 每个数组9个值
# 用于随时更新 FEN 棋子布局, 方便导出
#
# 默认开局: 
#[FEN "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1"]

## 正常开局时, 棋盘上某一行(line9-line0)的原始棋子代码,中间没有空格,后面不带/
# LFEN_00   

## LFEN_BETA: 走棋后, 某一行棋子代码排位.可能中间出现 1c511 这样的无效格式.
#    需要把相邻的数字(即无子空位)合并, 调整为 1c7 的合法格式 (即 LFEN_OK)；
#    
# LFEN_BETA #
# LFEN_OK

## LFEN_FROM: 走棋前的棋子坐标； LFEN_TO: 走棋后,棋子的新坐标；
# LFEN_FROM
# LFEN_TO


declare -a line9 line8 line7 line6 line5 line4 line3 line2 line1 line0
# 标准开局中, line8=line5=line4=line1=空行无子

line9=( r n b a k a b n r )

line8=( 1 1 1 1 1 1 1 1 1 )

line7=( 1 c 1 1 1 1 1 c 1 )
line6=( p 1 p 1 p 1 p 2 p )

line5=line8
line4=line8

line3=( P 1 P 1 P 1 P 1 P )
line2=( 1 C 1 1 1 1 1 C 1 )

line1=line8

line0=( R N B A K A B N R )

## T143: 
## STR_LINEX=``


### 5. 棋子走法输出内容相关 ###
#   STR_RESULT: 胜负代码. 用于写入 [Result ""]标签；
#       如: 1-0(红胜), 0-1(黑胜), 1/2-1/2(和棋), * (对局结束). 
#
#   TEXT_RESULT: 胜负输出的文字备注. 以评论的形式, 写在花括号内.
#       如: {红胜},{黑胜},{和棋},{对局结束}
#
# STR_RESULT 
# TEXT_RESULT

### 6. PGN_UUID 对局索引相关 ###
PGN_SN=`date +%s`
declare -i PGN_NUM FEN_NUM

### T138: 
## 提取随机字符, 保存到变量 STR_TMP (10位字符), 作为 PGN_UUID 最后面一段附加码
#  最大限度防止 PGN_UUID 重码(即使是同一电脑同时运行多个 cchess 进程).
#  如: /tmp/tmp.Inqcwg4DVq --> Inqcwg4DVq
#
# STR_TMP=`mktemp -u`
# ## 在即将保存对局结果时,再对 STR_TMP 取值,即在获取 date +%s UNIX 纪元时的
## 同时,才取值

# PGN_4DATE=''

## PGN/FEN 对局索引 PGN_UUID 的编码规则1: (暂定方案, 未正式使用, 功能开发中)

## PGN_UUID 的构成:
#  PGN_UUID = PGN_SN (10位) + (_) + PGN_4DATE (4位) + PGN_NUM (4位) + STR_TMP (10位)
#  如: PGN_UUID="_1234567890_17AA0001" # 29位字符
#
## 第1组: PGN_SN (10位序列号附加码), 即用当前时间的UNIX纪元时字符串
#  (通常为10位数字), 当成 PGN_UUID
#  的前置字符串, 避免因为 PGN_UUID 序号重号产生的意外覆盖和PGN丢失.
#
## 第2组: PGN_4DATE (4位)
# 前4位为年月日代码; 后４位数字为序号0001-9999, 超过9999后从0001重新计数
# DATE_2Y: 第1,2位字符: 17代表2017年
# DATE_1M: 第3位字符:   1-9:代表1-9月; 小写字母abc: 10-12月
# DATE_1D: 第4位字符:   1-9: 1-9日; 小写字母a-v: 10-31日

## T177:

_mk_pgn_datetime () {

    ## 记录当前的 Unix纪元时字符串 DATE_UNIX (共10位数字,精确到秒),再转换为
    ## PGN_UUID 使用的字符串格式
## date 参数用法示例:
##    

## $ date -d  '@2147483647'
## 2038年 01月 19日 星期二 11:14:07 CST
##
## DATE_06HMS: 时分秒(共6位数字)
## $ date -d  '@2147483647' +%H%M%S
## 235959 

 ### 一定要等到要用 _mk_pgn_datetime 函数了, 再对 DATE_UNIX 取值. 不要提前运行
## DATE_UNIX=`date +%s`

### 生成10位随机字符串, 用作 PGN_UUID 的附加码(随机码), 防止重号
STR_TMP=`mktemp -u | cut -d'.' -f2`

    
## 
DATE_06HMS=`date -d "@${DATE_UNIX}" +%H%M%S`

# DATE_2Y=`date +%y`
DATE_2Y=`date -d "@${DATE_UNIX}" +%y`

## ----
## 先得到月份的2位数字(01-12),再转换为1位代码
# DATE_1M=`date +%m`
DATE_1M=`date -d "@$DATE_UNIX" +%m`

case "$DATE_1M" in
      0[1-9])# 去掉前面多余的0, 只保留第2个数字
	  DATE_1M=`echo "$DATE_1M" | cut -c 2`
	   ;;

      1[012])if [ "$DATE_1M" = 10 ]; then DATE_1M='a';
	   elif [ "$DATE_1M" = 11 ]; then DATE_1M='b';
	   elif [ "$DATE_1M" = 12 ]; then DATE_1M='c';
	   else DATE_1M=`echo "$DATE_1M" | cut -c 2`
	     fi
	   ;;
    
    
      *)DATE_1M=`echo "$DATE_1M" | cut -c 2`
	;;
    
  esac

## ====

## ----
## 先得到 '日' 的2位数字(01-31),再转换为1位代码
# DATE_1D=`date +%d`
DATE_1D=`date -d "@$DATE_UNIX" +%d`

  case "$DATE_1D" in
      0[1-9])# 去掉前面多余的0, 只保留第2个数字
	  DATE_1D=`echo "$DATE_1D" | cut -c 2`
	   ;;

      1[0-9]) DATE_1D=`echo "$DATE_1D" | cut -c 2 | tr '0-9' 'a-j'`
	   ;;
      2[0-9]) DATE_1D=`echo "$DATE_1D" | cut -c 2 | tr '0-9' 'k-t'`
	   ;;
        3[01])if [ "$DATE_1D" = 30 ]; then DATE_1D='u';
	   elif [ "$DATE_1D" = 31 ]; then DATE_1D='v';
	   else DATE_1D=`echo "$DATE_1D" | cut -c 2`
	     fi
	;;  
    
      *)DATE_1D=`echo "$DATE_1D" | cut -c 2`
	;;
    
  esac
## ====

  PGN_4DATE="${DATE_2Y}${DATE_1M}${DATE_1D}"

  #DEBUG=1 
  if [ "$DEBUG" = 1 ]; then
    echo "L227: `date -I`  PGN_4DATE=$PGN_4DATE"
    sleep 1
  fi

}



  
### 11: 其它定义及待开发/预设的功能变量 ###

###

### T93: 
## PGN_HEAD: 单个对局的 PGN 临时文件头.
# 主要用于同一个PGN文件中,有多个对局的情况:
# 把每个对局都写入单独的临时文件,是为了方便修改标签,如胜负结果,
# FEN棋局修改(如残局图, 或非标准开局, 让子,等), PGN索引序号等,
# 而不会对同一PGN文件中的其它对局的标签产生误操作或批量修改；
#     注: 在保存 PGN 时运行即可.
## PGN_HEAD=`mktemp` 

## 记录中文走法(如炮二平五,车1进1)到临时文件,
# 便于实现悔棋后的数据修改操作. 开始新对局后,会重新运行一次,不会干扰上次对局
# 的数据
## T125: 
#PGN_BODY=`mktemp`

##  init, 用于记录导出的 PGN 对局/棋谱文件，以及 FEN 棋局的序号，
# 并保存到配置文件 cchess.cfg, pgn.index, fen.index ．
# 类似于数码相机里照片的文件名序号，
# 防止保存时文件重名造成的覆盖和数据丢失


### 91. 内部函数及选项帮助功能输出 ###

_init_cfg () {
    cat<<EOF
[$APPNAME $VERSION] 

### 默认保存/导出的文件序号
[PGN]
PGN_NUM="1"

[FEN]
FEN_NUM="1"
EOF
}


### PGN 相关
# PGN 文件结构组成:
# 1. 文件头(标签组), 先写入临时文件,用于结束对局后修改胜负,
# 2. 自定义标签组
# 3. 走棋记录,及胜负结果代码, 以示简单的胜负说明文字.
#    也先写入临时文件,方便悔棋后,删除原来的部分走法； 
# 4. 附加的评论(以花括号包起来). 可以在保存/导出 PGN 后,把手动编写的评论,
#    添加到 PGN 文件后面, 用来制作棋谱.

# [Date "`date +%Y.%m.%d`"]
# [Date ""]
_mk_pgn_head () {
cat <<EOF
[Game "Chinese Chess"]
[Event ""]
[Round ""]
[Date ""]
[Site ""]
[Red ""]
[RedTeam ""]
[Black ""]
[BlackTeam ""]
[Result "*"]
[Opening ""]
[Variation ""]
[ECCO ""]
EOF
}


## 自定义的标签
# Format: 即棋子走法的记录格式,有 Chinese, WXF, ICCS 三种
#     默认为 Chinese (即炮二平五)的形式.
# Index: 对局的序列号,方便定位同一PGN文件中的多个对局,或者制作棋谱
#     数值一般为19位字符, 如: 1234567890_17aa0001
#     也是默认的 PGN/FEN 文件名.
# Time: 记录对局的时间, 时分秒
# TimeControl: 对局限时规则, 如 "局时 10:00 步时 3:00"


# [Time "`date +%H:%M:%S`"]
# [Time ""]
_mk_pgn_custom () {
cat <<EOF
[Generator "cchess"]
[Format "Chinese"]
[Index ""]
[Time ""]
[TimeControl ""]
EOF
}

### 可能会在 mk_default_fen 后面加上代表评论功能的一对花括号 {},
# 而 _show_default_fen 只有一行 FEN 标签. 主要用于随时保存和导出棋局图

_mk_default_fen () {
    cat <<EOF
[FEN "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1"]
EOF
}

_show_default_fen () {
    cat <<EOF
[FEN "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1"]
EOF
}

#
_mksample_pgn_body () {
    cat <<EOF
  1. 炮二平五 马８进７
  2. 马二进三 车９平８
  3. 车一平二 马２进３
  4. 马八进九 卒７进１
  5. 炮八平七 车１平２
  6. 车九平八 炮２进４
  7. 车二进四 炮８平９
  8. 车二平四 车８进１
  9. 兵九进一 车８平２
 10. 车八进一 车２进３
 11. 车八平四 车２平４
 12. 前车进二 车４进３
 13. 炮七进四 士４进５
 14. 前车平三 马７退９
 15. 车四进三 车４退４
 16. 炮五平八 炮２平１
 17. 炮八平七 炮９平５
 18. 仕四进五 象３进１
 19. 车三平一 马９进７
 20. 车一平三 马７退９
 21. 车四进四 象１进３
 22. 车四平一 车４平３
 23. 车三进三
EOF
}


## disabled
_mk_pgn_end () {
cat <<EOF
*
EOF
}


### WXF代码, 辅助操作代码说明

_sample_wxf_00 () {
    cat<<EOF

 ------------------------
序号 代码   中文输出           说明

 1* 15+1 帅五进一 (或将5进1)  1-7代表红方: 帅仕相马车炮兵
 2* 26+5 仕六进五 (或士6进5)    (或者黑方: 将士象马车炮卒)
 3* 37+5 相七进五 (或象7进5)  第3个字符 + 代表进
 4* 48-7 马八退七 (或马8退7)  第3个字符 - 代表退
 5* 59+1 车九进一 (或车9进1)
 6* 62.5 炮二平五 (或炮2平5)  第3个字符 . 代表平
 7* 73+1 兵三进一 (或卒3进1)

 8* 7+.1 前兵平一 (或前卒平1)  第2个字符 + 代表前; -代表中; .代表后
 9* 7-.1 中兵平一 (或中卒平1)  
10* 7..1 后兵平一 (或后卒平1)  

11* 7a.1 一兵平一 (或一卒平1)  兵/卒的特例: 第2个字符用小写字母abcde
12* 7b.1 二兵平一 (或二卒平1)    分别代表同一条竖线有4个或5个兵/卒(最前面是一);
13* 7c.1 三兵平一 (或三卒平1)    或者有两条竖线都有2个或3个兵/卒.
14* 7d.1 四兵平一 (或四卒平1)    详细的一二三四五定义,见 <<中国象棋-着法表示>>
15* 7e.1 五兵平一 (或五卒平1)    www.xqbase.com/protocol/cchess_move.htm 
  abcde定义简介:最右前为一,同一竖线为二(或者二,三),完了再左边的竖线,最前到最后;
  如果五个兵卒是2+2+1分布,单独的兵/卒属于标准走法(如兵几进几,兵几平几);
 -------------------------

EOF
}

_sample_wxf_mini () {
    cat <<EOF
* 请输入4位象棋走棋代码 (或者输入 help 查看用法)
*    例: 15+1 代表帅五进一 (红方), 或者将5进1 (黑方)
         25-4 代表仕五退四 (红方), 或者士5退4 (黑方)
         75.4 代表兵五平四 (红方), 或者卒5平4 (黑方)
         .... 某方让先(或者停走). 显示为连续三个点号

         **** {对局结束}(胜负不确定). 类似的代码还有:
              **++ {红胜}, **-- {黑胜}, **.. {和棋}   

         //++ [评论模式]
              切换到 [评论模式]. 输入的文字会当成评论(用花括号包起来), 写入
              PGN 对局/棋谱文件. 按回车键后, 再按 Ctrl + C 可返回 [走棋模式]

EOF
}


_sample_wxf_extra () {
    cat<<EOF
 -------------------------
最后更新: 2017-1-23

注1: 以下属于自定义的操作代码, 用于手动记录棋谱, 并不是WXF定义的标准代码;
注2: 大多数代码功能暂未实现,仅定义为可扩展的功能. 在程序后续版本中,
     操作代码/功能可能会变更/增补.
操作代码版本: 0.1

序号 代码   中文输出           说明

* "让先(停走)/让子"相关代码

21* .... ...                某方让先(或者停走)
22* 0151 {红让车一} (或:0051 {黑让车1} 
      含义: 红方/黑方没有1路车(用于以评论形式记录让子信息).
      如: 红方让1路车和2路马, 依次走 0151 0142 两步即可. 格式说明:
         第1位: 0代表进入 [让子模式]；  第2位: 1代表红方,0代表黑方;
         第3位: 棋子代码(1-7);  第4位: 棋子是在1-9哪条竖线上(几路);

* "胜负结果"相关代码

23* **** *{对局结束}     胜负不确定. 以**开头的代码主要用于快速记录对局胜负.
24* **++  1-0 {红胜}    用于在 [Result ""]标签中记录胜负结果. 黑胜/和棋同理.
25* **--  0-1 {黑胜}
26* **..  1/2-1/2 {和棋}

* 其它"胜负结果"相关功能代码 (用花括号{ }包起来,并保存到 PGN 对局/棋谱文件)

27* 0000 {红(黑)方认输}   即没必要再走棋了
28* ***. {红(黑)方提和}   需要等对方同意, 才算正式和棋  
29* 00.. {双方议和}       同意和棋(对局结束). 
      快速记忆法: 00代表双方都不想下了, .. 代表和棋

* "规则判定结果"相关代码 (快速记忆法: **开头,后面跟2个数字)

30* **24 {红(黑)方超时判负}   快速记忆法: 一天是24小时.24表示时间相关
31* **60 {{红(黑)方回合数超限判和}  如:双方60回合都未吃子,按棋规,判和
32* **99 {{红(黑)方停止走棋}   如:中途离开,网络掉线,程序意外退出.(久等不来)

* 可以直接判定胜负的简单棋局 (快速记忆法: ..开头表示没必要再继续走棋了
  ----再继续走下去, 也是浪费时间)

33* ..00 {例和}          如:双方都没有可进攻的棋子(都没有车马炮兵卒)
      快速记忆法: 前面..代表应该就是和棋, 后面的00代表没有什么好走的

34* ..-- {{红(黑)方例负}  可直接判定胜负的简单棋局,如:对方单马杀孤将

35* ---- {红(黑)方困毙}   轮到某方走棋时,无子可走
36* 99-- {绝杀}          强制判定走棋方为负(即对方胜利). 如:下一步有子可走,
    但属于自杀式走法(如将帅直线对面);或者后面的走法是很明显的连续叫将, 无法解救.
    (快速记忆法:99八十一难, 危机重重)

37* ++-- {{红(黑)方长将判负}   快速记忆法: ++代表强行叫将
38* --.. {{红(黑)方长捉/长拦/重复走棋判和} 包括"双方重复走棋三回合, 不变作和

* 保存/导出 PGN 对局/棋谱文件 (快速记忆法:3个999代表与PGN对局/棋谱有关)

39* 9991 {保存PGN对局}  把单个对局保存为PGN对局/棋谱文件, 再新建另一个PGN文件
40* 9992 {保存PGN连续对局}    用于在同一个PGN对局/棋谱文件中,连续记录多局对战

* 保存/导出 FEN 棋局文件 (快速记忆法:3个+++代表与FEN棋局有关)

41* +++1 {导出FEN棋局}  把当前棋局的棋子排位,导出为单独的FEN棋局数据串文件
42* +++2 {导出连续FEN棋局}     在同一个FEN棋局文件中,连续记录多个棋局.
                       可用于动画演示走棋,或者记录一本棋谱的全部棋局图; 
43* +++9 {保存FEN棋局到PGN}  把当前棋局的棋子排位,以花括号评论的形式,
                           添加到当前的PGN对局/棋谱文件

44* //// {红(黑)方悔棋}

45* //++ [评论模式]  切换到 [评论模式]. 输入的文字会当成评论(用花括号包起来), 
        写入 PGN 对局/棋谱文件. 按回车键后, 再按 Ctrl + C 可返回 [走棋模式]


* 辅助操作代码统计(共25个)

**开头 1+3+1+3=8
0开头  1+1+1=3
9开头  1+2=3
++开头 1+3=4
--开头 1+1=2
..开头 1+2=3
//开头 1+1=2

 -------------------------

EOF
}


###
_option_done () {
    cat<<EOF
 -------------------------
注1: 以下属于自定义的操作代码, 用于手动记录棋谱, 并不是WXF定义的标准代码;
注2: 后续版本可能会增加新的操作代码, 或者调整操作代码的功能

操作代码版本: $VERSION

序号 代码   中文输出           说明

* "让先(停走)/让子"相关代码

21* .... ...                某方让先(或者停走)

* "胜负结果"相关代码

23* **** * {对局结束}  胜负不确定. 以**开头的代码主要用来手动记录棋谱.
24* **++  1-0 {红胜}  用于在 [Result ""]标签中备注胜负结果. 黑胜/和棋同理.
25* **--  0-1 {黑胜}
26* **..  1/2-1/2 {和棋}
27* 0000 {红(黑)方认输}   即没必要再走棋了

29* 00.. {双方议和}       同意和棋(对局结束). 
      快速记忆法: 00代表双方都不想下了, .. 代表和棋

33* ..00 {例和}          如:双方都没有可进攻的棋子(都没有车马炮兵卒)
      快速记忆法: 前面..代表应该就是和棋, 后面的00代表没有什么好走的

45* //++ [评论模式]  切换到 [评论模式].  
-------------------------

EOF
}

_option_next () {
cat<<EOF
 -------------------------
注1: 以下属于自定义的操作代码, 用于手动记录棋谱, 并不是WXF定义的标准代码;
注2: 后续版本可能会增加新的操作代码, 或者调整操作代码的功能

操作代码版本: $VERSION

序号 代码   中文输出           说明

* "评论"相关代码

45* //++ {开始评论}       切换到评论编辑状态, 输入的文字内容会包含在花括号里
   (退出评论状态: 输入完评论内容后, 再按一次回车键, 换新行, 再同时按 Ctrl 和 C
   键, 即可返回"走棋代码输入"模式)  
 -------------------------

* 其它功能

101* 对简单的让子棋(如让单马/单车, 或者其它棋子), 可以直接修改 FEN 棋局数据, 
     保存到开局 FEN 标签中 (相当于以残局形式进行的开局, 而不是标准开局)

* 待修复的问题

200* 目前暂只对各兵种棋子的走法合理性进行初步分析和判定, 未仔细计算棋子坐标位
     置和周围棋子的障碍环境, 以及是否处于被叫将的状态. 因此走棋的合理性, 还需
     要用户自己确定走棋的有效性. (如: 兵/卒未过河前, 是不可以左右移动的)

EOF
}

#,fuzzy
# 读取走棋输入时的光标定位
CLINES=`tput lines`
CCOL="20"

### 
_option_uuid () {
### must run as root only!
#    echo "  * generate UUID for disk, partition, netcard MAC (save to $ETC_DIR/UUID)"
# [ `whoami` = "root" ] || { echo -e "\n\troot please!"; exit 0; }



### 每种 UUID 只取第一个, 其它的忽略 (如多块硬盘, 多个分区, 多个网卡)
## example: disk:        VNC202x2H4X27A    (14位)
##          partition:   02A43798A4378CE3  (16位)
    ##          netcard MAC: 000ae4626345      (12位)

    if [ -s "$ETC_DIR/UUID" ]; then
	echo -e "  !!! WARNG: $ETC_DIR/UUID existed. now force overwrite.\n"
    fi
    
    : > "$ETC_DIR/UUID"
    
    echo "  * 1. frist Disk UUID (cmd: hwinfo --disk)..."
DISK_UUID=`hwinfo --disk | grep -i "Serial ID:" | head -1 | cut -d'"' -f2`
    echo "DISK_UUID=$DISK_UUID" | tee -a "$ETC_DIR/UUID"
    echo;


    echo "  * 2. frist Partition UUID (cmd: hwinfo --partition)..."
    PARTITION_UUID=`hwinfo --partition | grep -i "uuid/" | head -1 | cut -d',' -f4 | cut -d'/' -f5`
    echo "PARTITION_UUID=$PARTITION_UUID" | tee -a "$ETC_DIR/UUID";
    echo
    
    
    echo "  * 3. frist Netcard MAC (cmd: hwinfo --network)..."    
    NETWORK_MAC=`hwinfo --network | grep -i "HW Address" | sed '/:/s///g' | cut -d' ' -f5`
    echo "NETWORK_MAC=$NETWORK_MAC" | tee -a "$ETC_DIR/UUID";
    echo;    

    
    echo "  Done."

}

### 
_option_bug () {
    cat<<EOF
  $APPNAME $VERSION 已知问题:


EOF
}

###
_option_thanks () {
    cat<<EOF
      鸣谢:

* 中国象棋百科全书网站 ( www.xqbase.com )
   早在2004年, 该网站就确立并统一了中国象棋软件开发的相关标准和技术细节. 
因为有了他们的努力, 中国象棋软件才在统一的框架下, 顺利实现技术开发和数据交流!

* Linux 下的中国象棋程序 Gmchess (天书棋谈), 作者 及维护团队
    因为有了你们, 象棋爱好者们终于在 Linux 下, 找到了一款满意的中国象棋软件!

* 所有关注, 支持以及参与 cchess 开发和维护的朋友
    因为有了你们, cchess 才能快速成熟, 完善和普及!

   最后, 致所有程序员: 

   若有光芒, 必有远方!

EOF
}


_usage_cn () {
cat<<EOF
用法: $APPNAME [选项]
在命令行下输入 WXF 格式中国象棋代码, 实现中国象棋棋谱(走棋记录)的
快速编写和录入, 并保存到PGN 对局文件。

* 附: 待开发的功能: 保存多个 FEN 棋局文件到 PGN 文件

选项
      --ok, --done       显示已完成的功能
      --next             显示正在编写的功能 (近期内可能实现设计的功能)
      --todo             显示规划中的功能 (短期内不太可能实现)
      --thanks           鸣谢
      --wxf 
              显示 WXF 世界象棋联合会(World XiangQi Federation)走棋代码示例

      --bug            显示已知问题和缺陷
      -v, --version    显示版本信息并退出
      -h, --help       显示帮助信息并退出

请发送缺陷报告给 Careone <emacslocale@126.com>.

主页:
* 1. 主程序 cchess 定期更新(开发版, 非稳定版本)
https://github.com/kuiba1949/cchess/

* (DEB 软件包下载)
https://sourceforge.net/projects/emacslocale/files/cchess/
EOF
}    

### HEAD END ###


### BODY ###

###---------------
for option in "$@"; do

    	case "$option" in
    	 -h | --help)
	 _usage_cn #暂只提供简体中文帮助信息
	exit 0 ;;


	--wxf | -wxf)
	  _sample_wxf_00
	  exit 0 ;;

	--ok | -ok | --done | -done)
	  _option_done
	  exit 0 ;;

	--next | -next)
	  _option_next
	  exit 0 ;;

	--todo | -todo)
	  _sample_wxf_extra
	  exit 0 ;;

	--thanks | -thanks)
	  _option_thanks
	  exit 0 ;;

	--bug | -bug)
	  _option_bug
	  exit 0 ;;

	--uuid | -uuid)
	    ### must run as root only!
	    echo    "  * read UUID/MAC (first disk/partition/netcard MAC only), " 
	    echo -e "    and save to: $ETC_DIR/UUID\n"
	    [ `whoami` = "root" ] || { echo -e "\n\troot please!"; exit 0; }	    

	    if [ ! -d "$ETC_DIR" ]; then
		mkdir -p "$ETC_DIR"
	    fi
	    
	    _option_uuid
	    
	    exit 0 ;;

    	-v | --version)
	  basename -- "$APPNAME $VERSION"
	  exit 0 ;;

    	-*)
	  echo "Unrecognized option \`$option'" 1>&2
	  exit 1 ;;
    esac

done


###---------------





### check and auto mkdir app configure dir
if [ ! -d "$CFG_DIR/" ]; then
  mkdir -p "$CFG_DIR/";
fi

### save/export PGN/FEN files to dir:
if [ ! -d "$PGN_DIR/" ]; then
  mkdir -p "$PGN_DIR/";
fi

if [ ! -d "$FEN_DIR/" ]; then
  mkdir -p "$FEN_DIR/";
fi


### TODO 540: 配置文件 cchess.cfg 暂未正式启用. 功能待开发
# 创建默认配置文件



if [ "$ENABLE_CFG" = 1 ]; then
    
    ###
    if [ ! -e "$CFG_FILE" ]; then
    :
    #  _init_cfg > "$CFG_FILE";
    fi

fi
### --------------------

### T774: 
### 读取配置文件和参数文件, 得到 PGN 和 FEN 的数字序号 PGN_NUM, FEN_NUM,
##  用于连续编号

## 如果存在 PGN_INDEX 参数文件, 则从文件读取数字作为 PGN_NUM 的参数 
if [ -r "$PGN_INDEX" ] && [ -s "$PGN_INDEX" ] ; then
    
    # PGN_NUM=`grep [0-9] "$PGN_INDEX" | head -1 | tr -s ' ' | sed '/ /s///' | cut -d' ' -f1`    
    PGN_NUM=`cat "$PGN_INDEX" | cut -f1`

    ### DEBUG
#echo "  L787: PGN_NUM=$PGN_NUM"
    
    ## 如果读取到的序号不是数字,强制更正为1, 并把更正后的数值写入
    #  pgn_index 参数文件
    #  注: 如果是0开头, 如 0001 ,结果待确认
    case "$PGN_NUM" in
	#[0-9][0-9][0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9] | [0-9]):
	*[^0-9]*)  PGN_NUM=1;
		    echo -n "$PGN_NUM" > "$PGN_INDEX";
			     ;;

	
	*):
	  #PGN_NUM=1;
	#	  echo "$PGN_NUM" > "$PGN_INDEX"; 
	;;
    esac
    
else ## 如果不存在这个文件, 新建一个, 默认序号从1开始. 
    ## T801: 
    PGN_NUM=1;
    echo -n "$PGN_NUM" > "$PGN_INDEX";
    
fi

## T791:
#DEBUG=1
    if [  "$DEBUG" = 1 ]; then
        echo "  L772: PGN_NUM=$PGN_NUM"
	#sleep 10;
    fi
    
## invoke cmd: convert_pgn
# convert other File format to [PGN-File]
# usage: convert_pgn 001.xqf 001.pgn
#It support [.ccm|.che|.chn|.mxq|.xqf]

CONVERT_PGN="convert_pgn"

#
  if [ "$KEEP_LOG" = 1 ]; then
    echo -e "\n`date`" >> "$LOG"
  fi


  ### READY TO GO! ###
### T812:
  



### 显示日期和时间标签, 用作提示, 以及方便手动复制到 PGN 文件头；
  if [ "$SHOW_DATETIME" = 1 ]; then
      echo -en "[Date \"`date +%Y.%m.%d`\"]  "
      echo -e  "[Time \"`date +%H:%M:%S`\"]"
  fi

  if [ "$SHOW_DEFAULT_FEN" = 1 ]; then  
      _show_default_fen
  fi
  

echo  " ------------------------- "


  if [ "$SHOW_DEFAULT_FEN" = 1 ]; then 
      _sample_wxf_mini

      #_sample_wxf_00
      #_sample_wxf_extra
     # echo
      echo  " ------------------------- "
  fi
  
## 创建一个标准 PGN 文件头(标签组), 保存到临时文件 (对局结束后,可能需要修改
#  胜负结果,以及其它标签,最后再合并到正式 PGN 文件)
#  程序会把当前日期,自动写入 [Date ""] 标签
#    (问题: 如果是录入昨天或者以前的对局,可能还需要手动修改 Date 标签)；

    PGN_HEAD=`mktemp`
    _mk_pgn_head > "$PGN_HEAD"
    
    ## 在 PGN 默认标签后面添加自定义标签, 写入 PGN_HEAD 文件头临时文件
    _mk_pgn_custom >> "$PGN_HEAD"


    
### 读取语言环境 CLANG ,决定是显示为简体还是繁体中文来显示走棋记录
#  TODO: 以后还可以考虑增加一个英文输出方案,方便外国友人下中国象棋.
#  如: P5+1 p3+1 (含义: 兵五进一 卒3进1)

# 技巧: 强制使用繁体中文或英文环境运行程序, 以测试繁体中文/英文走法的文字输出
    # LANG=zh_TW cchess
    # LANG=en cchess  
    
  case "$CLANG" in

      zh_TW | zh_HK | zh_SG)# 繁体中文
R1="帥"
R2="仕"
R3="相"
R4="馬"
R5="車"
R6="炮"
R7="兵"

B1="將"
B2="士"
B3="象"
B4="$R4"
B5="$R5"
B6="砲"
B7="卒"

FORWARDS="進"
BACKWARDS="退"
SIDEWARDS="平"
;;
      zh_CN | *) # 简体中文
      R1="帅"
R2="仕"
R3="相"
R4="马"
R5="车"
R6="炮"
R7="兵"

B1="将"
B2="士"
B3="象"
B4="$R4"
B5="$R5"
B6="$R6"
B7="卒"

# TODO 691: 保留的变量, 后期版本中, 再完成输出代码的优化, 统一使用变量
FORWARDS="进"
BACKWARDS="退"
SIDEWARDS="平"

# FRONT="前"
# MIDDLE="中"
# BEHIND="后"

# ONE="一"
# TWO="二"
# THREE="三"
# FOUR="四"
# FIVE="五"
# SIX="六"
# SEVEN="七"
# EIGHT="八"
# NINE="九"

# RED="红"
# BLACK="黑"

# MISS="让"

# WIN="胜"
# LOSS="输"
# DRAW="和"

;;
      
      999) # 待开发的功能, 仅适用于外国用户显示为棋子为单个大写/小写字母代码
	  ## 大写字母代表红方,小写代表黑方
      R1="K"
R2="A"
R3="B"
R4="N"
R5="R"
R6="C"
R7="P"

B1="k"
B2="a"
B3="b"
B4="n"
B5="r"
B6="c"
B7="p"

FORWARDS="+"
BACKWARDS="-"
SIDEWARDS="."
;;
  
  esac
  
## T813: 
PGN_BODY=`mktemp`

while true; do

    ## T814:
    #tput cup "$CLINES" "$CCOL"
    tput sc


    
read -n 4 STRING

case "$STRING" in

    ### 情况１：让步(让先, 停走),
    # 
    ....)
	## T821:

	#
	
  if [ "$DEBUG" = 1 ]; then
    echo
      echo -e "\tL81: STEP=$STEP, LOOP=$LOOP; TRUN=$TRUN"
  fi
  
  tput rc; tput ed;

  if [ "$PAUSED" != 1 ]; then



  ### T838: ----
  if [ "$TRUN" = 1 ]; then
      ## TODO 689: 暂不支持输出纯英文格式的 让先代码(... ), 功能待补充
      #echo -en "$LOOP. ...   " | tee -a "$PGN_BODY";　# English
      #
      #中文全角格式: 3个点号和1个空格, 共4个字符
      echo -en "$LOOP. ．．．　  " | tee -a "$PGN_BODY"; 
      
    TRUN=0
#  else echo -e "..." | tee -a "$PGN_BODY"; # English
  else echo -e "．．．　" | tee -a "$PGN_BODY"; # 4个中文全角字符
       
       let "LOOP += 1";
       TRUN=1;
  fi
  ### ====
  
  tput sc
  #tput cup "$CLINES" "$CCOL"


  ## PAUSED=1: 已经走了一步让子棋. 下一步对方就不能再停走----没有这么下棋的
  PAUSED=1
  
  let "STEP += 1";
  continue;
  
    else   tput rc; tput ed; continue;

  fi
  ;;
    ### T826: 

  ### 情况２：正常棋子走法
  # S1-S4: 截取的第1到4个字符
  # SN1-SN4: 转换后的中文走棋文字，如：帅五平四，将5平4．
  #     当黑方的S2/S4是数字1-9时， SN2=S2, SN4=S4
  # SN8: 转换后中文走法的前2个字，主要是针对多子同线的情况．
  #      如：帅五，前/中/后兵，一/二/三/四/五兵
  

    ### T836
    [1-7][1-9\+\-\.abcdeABCDE][\+\-\.][1-9])
#      	[1-7]???)

		## T629.2:
	# 问题: 一方让先,另一方走子后, 可能导致后续的回合数计数临时重复(暂停)
	# 可能是 ..* 条件 与 [1-7]??? 条件代码交替运行时的累加交接异常 
	# 如:
	
    S1=`echo "$STRING" | cut -c 1`
    S2=`echo "$STRING" | cut -c 2`
    S3=`echo "$STRING" | cut -c 3`
    S4=`echo "$STRING" | cut -c 4`
    
if [ "$DEBUG" = 1 ]; then
  echo -e '\t'
  #echo "L155: TRUN=$TRUN; ${S1}${S2}${S3}${S4}"
  #  sleep 1
fi

    ### 走棋代码第1位
# 说明: tr 命令对中文全角文字和符号无法正确处理, 需要改用 sed,
# 或者 case 语句

    case "$TRUN" in
	1) #红方棋子名称转换(数字1-7转成中文棋子).
	    # 如果是针对外国用户,可能是数字转为单个大写或小写字母(功能暂未开放)
    #SN1=`echo "$S1" | sed 's/1/帅/g;s/2/仕/g;s/3/相/g;s/4/马/g;s/5/车/g;s/6/炮/g;s/7/兵/g'`
case "$S1" in
	1)SN1="$R1" ;;
	2)SN1="$R2" ;;
	3)SN1="$R3" ;;
	4)SN1="$R4" ;;
	5)SN1="$R5" ;;
	6)SN1="$R6" ;;
	7)SN1="$R7" ;;
	*)contiune ;;
esac


    ;;
	
	0) # 黑方
#    SN1=`echo "$S1" | sed 's/1/将/g;s/2/士/g;s/3/象/g;s/4/马/g;s/5/车/g;s/6/炮/g;s/7/卒/g'`
case "$S1" in
	1)SN1="$B1" ;;
	2)SN1="$B2" ;;
	3)SN1="$B3" ;;
	4)SN1="$B4" ;;
	5)SN1="$B5" ;;
	6)SN1="$B6" ;;
	7)SN1="$B7" ;;
	*)contiune ;;
esac
      ;;
	
	
	*)SN1="$S1";
	  #break;
	  #contiune;
    ;;    
    esac

    
    ### 走棋代码第2位

    case "$S2" in
	[1-9])
	    if [ "$TRUN" = 1 ]; then
		SN2=`echo $S2 | sed 's/1/一/g;s/2/二/g;s/3/三/g;s/4/四/g;s/5/五/g;s/6/六/g;s/7/七/g;s/8/八/g;s/9/九/g'`

 	    else #黑方走法
		if [ "$BLACK_MOVE_FORMAT" = 1 ]; then
		    # =1: 黑方走法用英文半角数字. 如果用字母 KABNRCP
		    #    分别代表帅仕相马车炮兵(大写为红方,小写为黑方)时,
		    #    需要采用这种模式(如保存为英文用户可读取的PGN文件,
		    #    或者方便外国友人练习中国象棋.如 P5+1 兵五进一.
		    #
		    # =0 或者其它: 用中文全角字符表示(排版整齐,适合中文用户)
		    #    齐效果.默认为0
		    SN2="$S2"
		else
		    SN2=`echo $S2 | sed 's/1/１/g;s/2/２/g;s/3/３/g;s/4/４/g;s/5/５/g;s/6/６/g;s/7/７/g;s/8/８/g;s/9/９/g'`
		fi
	    fi
	    SN8="${SN1}${SN2}"; #标准走法
	    ;;
	
	[aAbBcCdDeE\+\.\-])
	
	    SN2=`echo $S2 | sed 's/+/前/g;s/\./后/g;s/-/中/g;s/[aA]/一/g;s/[bB]/二/g;s/[cC]/三/g;s/[dD]/四/g;s/[eE]/五/g'`
	    
	    SN8="${SN2}${SN1}";
	    ## 特殊走法，如: 前/中/后兵平一；一/二/三/四/五/兵平四
	    # +/-/. = 前/中/后
	    # a/b/c/d/e = 一/二/三/四/五
	    ;;
	*)SN2="$S2";
	  SN8="${SN1}${SN2}"; #标准走法
	    ;; 
    esac

    
    ### 走棋代码第3位

    case "$S3" in
	## 如果 FORWARDS (前), BACKWARDS(退), SIDEWARDS(平)
	## 没有定义对应的文字或字符, 则使用默认的 +-. 代码代替
	   +)if [[ -n "$FORWARDS" ]]; then SN3="$FORWARDS";
	     else SN3="$S3";
	     fi  ;;
	   -)if [[ -n "$BACKWARDS" ]]; then SN3="$BACKWARDS";
	     else SN3="$S3";
	     fi  ;;
	   
	   \.)if [[ -n "$SIDEWARDS" ]]; then SN3="$SIDEWARDS";
	     else SN3="$S3";
	     fi  ;;

	   *)SN3="$S3" ;;
	esac


    ### 走棋代码第4位
        case "$S4" in
	[1-9])
	    if [ "$TRUN" = 1 ]; then #红方走法
		SN4=`echo $S4 | sed 's/1/一/g;s/2/二/g;s/3/三/g;s/4/四/g;s/5/五/g;s/6/六/g;s/7/七/g;s/8/八/g;s/9/九/g'`
	    else #黑方走法
		if [ "$BLACK_MOVE_FORMAT" = 1 ]; then
		    # =1: 黑方走法用英文半角数字； =0或者其它: 中文全角字符,有更好的排版对齐效果.默认为0
		    SN4="$S4"
		else
		    SN4=`echo $S4 | sed 's/1/１/g;s/2/２/g;s/3/３/g;s/4/４/g;s/5/５/g;s/6/６/g;s/7/７/g;s/8/８/g;s/9/９/g'`
		fi
		
	    fi
	    ;;
	
	*) SN4="$S4" ;
	;;
	esac

	### 判断走棋是否合法
	case "$S1" in
	    1) #帅／将
		case "$S2" in
		    4 | 6)
			if [ "$S4" = '1' ] && [ "$S3" = '+' ]; then : ;
		      elif [ "$S4" = '1' ] && [ "$S3" = '-' ]; then : ;
		      elif [ "$S4" = '5' ] && [ "$S3" = '.' ]; then : ;
		      else
			  tput rc; tput ed; continue;
			  :
		      fi
		      
			  ;;
		    
		    5)
			if [ "$S4" = '4' ] && [ "$S3" = '.' ]; then : ;
		      elif [ "$S4" = '6' ] && [ "$S3" = '.' ]; then : ;
		      elif [ "$S4" = '1' ] && [ "$S3" = '+' ]; then : ;
		      elif [ "$S4" = '1' ] && [ "$S3" = '-' ]; then : ;
			else tput rc; tput ed; continue;
			fi
			
			  #continue;
			  ;;
		    
		    *) 
			tput rc; tput ed; continue;
		      ;;
		    esac
		   ;;
	    2): #仕／士
	      case "$S2" in
	      	  4 | 6)
			if [ "$S4" = '5' ] && [ "$S3" = '+' ]; then : ;
		      elif [ "$S4" = '5' ] && [ "$S3" = '-' ]; then : ;
		      else tput rc; tput ed; continue;
		      fi
		        ;;
		    
		    5)
			if [ "$S4" = '4' ] && [ "$S3" = '+' ]; then : ;
			elif [ "$S4" = '4' ] && [ "$S3" = '-' ]; then : ;
			elif [ "$S4" = '6' ] && [ "$S3" = '+' ]; then : ;
			elif [ "$S4" = '6' ] && [ "$S3" = '-' ]; then : ;
			else tput rc; tput ed; continue;
			fi
			  ;;
		    *) 
			tput rc; tput ed; continue;
		      ;;
		   esac
				  
	    ;;
	    3): #相／象
	      case "$S2" in
	      	   3)
			if [ "$S4" = '5' ] && [ "$S3" = '+' ]; then : ;
	    	      elif [ "$S4" = '5' ] && [ "$S3" = '-' ]; then : ;
		      elif [ "$S4" = '1' ] && [ "$S3" = '+' ]; then : ;
		      elif [ "$S4" = '1' ] && [ "$S3" = '-' ]; then : ;
		      else tput rc; tput ed; continue;
		      fi
		        ;;
		    
		    7)
			if [ "$S4" = '5' ] && [ "$S3" = '+' ]; then : ;
	    	      elif [ "$S4" = '5' ] && [ "$S3" = '-' ]; then : ;
		      elif [ "$S4" = '9' ] && [ "$S3" = '+' ]; then : ;
		      elif [ "$S4" = '9' ] && [ "$S3" = '-' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
	      	    5)
			if [ "$S4" = '3' ] && [ "$S3" = '+' ]; then : ;
	    	      elif [ "$S4" = '3' ] && [ "$S3" = '-' ]; then : ;
		      elif [ "$S4" = '7' ] && [ "$S3" = '+' ]; then : ;
		      elif [ "$S4" = '7' ] && [ "$S3" = '-' ]; then : ;
		      else tput rc; tput ed; continue;
		      fi
		        ;;
		    
		    1)
			if [ "$S4" = '3' ] && [ "$S3" = '+' ]; then : ;
	    	      elif [ "$S4" = '3' ] && [ "$S3" = '-' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
		    9)
			if [ "$S4" = '7' ] && [ "$S3" = '+' ]; then : ;
	    	      elif [ "$S4" = '7' ] && [ "$S3" = '-' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			  ;;
		    *) 
			tput rc; tput ed; continue;
		      ;;
	      esac
	      ;;
	    
	    4)
		## 马: 不会出现三马并线的"中马(进/退/平)几" (第2位代码-),或者
		# 4/5个马并线的"(一/二/三/四/五)马平几"的走法(第2位代码abcde).
		# 车, 炮同理.
		case "$S2" in
		    [a-eA-E\-])tput rc; tput ed; continue;
		    ;;
		esac
		
		;;
	    
	    5): #车
		case "$S2" in
		    [a-eA-E\-])tput rc; tput ed; continue;
		    ;;
		esac
		;;
	    
	    6): #炮
	        case "$S2" in
		    [a-eA-E\-])tput rc; tput ed; continue;
		    ;;
		esac
	    ;;
	    7) #兵／卒
	      case "$S3" in
                  +) #兵／卒前进时只能进一步
		      if [ "$S4" != 1 ]; then
			  tput rc; tput ed; continue;
		      fi
		      
		      ;;
                  -) #兵／卒不能后退
		      tput rc; tput ed; continue;
		      ;;
                  \.) #兵／卒左右平移时，只能移到相邻的竖线
			  
		      case "$S2" in
			  # 两个或者最多5个兵／卒在同一条直线的情况
			  [a-eA-E+-.]): ;;
			  
			  5)# T902: 75.4 报错(应为兵五平四/卒5平4)
			      # 实际上兵/卒平移时都无法识别.
			      # 2017-1-20 已修复
			      
			  if [ "$S4" = '4' ] || [ "$S4" = '6' ]; then : ;														      
 			else tput rc; tput ed; continue;
			fi
			;;
			  
			  7)
			if [ "$S4" = '8' ] || [ "$S4" = '6' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			  3)
			if [ "$S4" = '4' ] || [ "$S4" = '2' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			4)
			if [ "$S4" = '5' ] || [ "$S4" = '3' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			  6)
			if [ "$S4" = '5' ] || [ "$S4" = '7' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			
			8)
			if [ "$S4" = '7' ] || [ "$S4" = '9' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			  2)
			if [ "$S4" = '3' ] || [ "$S4" = '1' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			  
			1)
			if [ "$S4" = '2' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			  9)
			if [ "$S4" = '8' ]; then : ;
 			else tput rc; tput ed; continue;
			fi
			;;
			  *)
		      tput rc; tput ed; continue;
		      ;;
		      esac
		      
		      ;;
		      ### CASE　兵／卒 $S2 vs. $S4 END
		      

		      *)
			tput rc; tput ed; continue;
		        ;;
		      #esac
	      esac
 	      ### CASE 兵／卒 $S3 END
	      
	      ;;
	    
	    *)## 其它无效的棋子数字代号(1-7以外的其它字符)
		tput rc; tput ed; continue; ;;
	    
	    esac
		      ### CASE: 7种棋子走子合法性判断完毕 END	

	### T1194: 
	# 输出中文走棋记录．走棋后再把步数 STEP +1，为下一步的步数计数器做准备
	tput rc; tput ed

	## D1125: TEXT_MOVE: 每步走法的4个字
	TEXT_MOVE="${SN8}${SN3}${SN4}"
	
	if [ "$TRUN" = 1 ]; then
	    # 红方走法
	    echo -en "$LOOP. $TEXT_MOVE  " | tee -a "$PGN_BODY";
	    TRUN=0; 
	else # 黑方走法
	    echo -e "$TEXT_MOVE" | tee -a "$PGN_BODY";
	    let "LOOP += 1";
	    TRUN=1;
	fi    
	tput sc
	#tput cup "$CLINES" "$CCOL"
	
	# 步数　+1，为下一步做准备
	let "STEP += 1";

	### 如果上一步(不管黑方红方)是让先/停走, 在走完这一步的正常走法后,
	#   把 停走标示 PAUSED 复位(意义下一步允许停走)
	if [ "$PAUSED" = 1 ]; then
	    unset PAUSED
	fi
	
    
    if [ "$DEBUG" = 1 ]; then
      echo
      echo -e "\tL1250: STEP=$STEP, LOOP=$LOOP; TRUN=$TRUN"
    fi
#esac  
    continue;
    ;;

    ### T1223:
    
# 辅助操作代码 T699
  \*\*\*\* | \*\*++ | \*\*-- | \*\*.. | 0000 | 00.. | ..00)
      ## 代码依次代表:
      # **** = * {对局结束, 胜负未知} 
      # **++ = 1-0 {红胜} 
      # **-- = 1-0 {红胜} 
      # **.. = 1/2-1/2 {和棋}
      # 00.. = 1/2-1/2 {双方议和}
      # ..0 = 1/2-1/2 {例和}
      #
      ## TODO: L1284
      # 0000 = 0-1(或1-0) {红/黑方认输}
      
      GAMEOVER=1 #对局是否结束. 1=结束,0=未知

      # 对局胜负结果代码, 用于保存到[Result ""]标签, 以及走法的最后面
      # 强制初始化变量,防止把上一局的对局结果,带到下一局,造成混乱
      
      STR_RESULT="*"
      unset TEXT_RESULT 
      
      case "$STRING" in
	  \*\*\*\*)STR_RESULT="*"; TEXT_RESULT="{对局结束}"
     	    tput rc; tput ed;
	    echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
		   ;;
	  \*\*++)STR_RESULT="1-0"; TEXT_RESULT="{红胜}" 
     	    tput rc; tput ed;
	    echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
	    ;;
	    
	    \*\*--)STR_RESULT="0-1"; TEXT_RESULT="{黑胜}" 
	     tput rc; tput ed;
	     echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
		    ;;

	    ### T1496: 和棋
	    \*\*..)STR_RESULT="1/2-1/2"; TEXT_RESULT="{和棋}"
	      tput rc; tput ed;
	      echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
	      ;;

	    00..)STR_RESULT="1/2-1/2"; TEXT_RESULT="{双方议和}"
	      tput rc; tput ed;
	      echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
	      ;;
	    
	    ..00)STR_RESULT="1/2-1/2"; TEXT_RESULT="{例和}"
	      tput rc; tput ed;
	      echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
	      ;;

	    ## 一方自动认输
	    0000)if [ "$TRUN" = 1 ]; then
		     STR_RESULT="1-0"; TEXT_RESULT="{黑方认输}"
		 else
		     STR_RESULT="0-1"; TEXT_RESULT="{红方认输}"
		     
		 fi
		 

	      tput rc; tput ed;
	      echo -e "\n${STR_RESULT} ${TEXT_RESULT}\n" | tee -a "$PGN_BODY"
	      ;;

	    *)## 其它操作代码的功能待确认. 无法识别的, 一律清除,重新输入
		tput rc; tput ed; continue; ;;
      esac
      

      ### TAG1553: 
      #PGN_NAME_STYLE="1"

      ### 保存的 PGN 文件名命名规则 (默认采用方案1). 各方案示例:
      # 方案1: 17av0001.pgn (推荐和默认的方案)
      #   或者 17av0001_161533_bkt0Da6ykb.png (如果17av0001.pgn 已存在,
      #   如索引文件 .pgn_index 被删除或更改, 或者多个 cchess 同时运行
      #   产生重名的情况. 后面的6位数字代表时分秒,最后面的10位是随机码
      #
      # 方案2: 2017-1231_2359-59-x1x2x3x4x5.pgn
      # 方案3: 17av0001_2017-1231_2359-59.pgn
      # 或者 方案3: 17av0001_2017-1231_2359-59-x1x2x3x4x5.pgn      


      ## 把数字 PGN_NUM 强制转换为4位数. 如果原数值大于4位,截取最后4位
      #  如果累计后大于 9999,重新从 0001 开始编号(暂未实现).
      #     
      #  注1: printf "%4s" 12345 的效果是保证不低于4位数.超过4位,显示全部
      #  注2: 当前代码是保证不低于4位数,5位数以上的,直接提取,不需要用 printf
      #       转换；

      ## 如果数字位数低于4位数,如 1-999, 需要在序号数字前补0,变成4位数,
      #  方便按文件名排序

        if [[ "$PGN_NUM" -le 999 ]]; then
	    PGN_4NUM=`printf "%4s" "$PGN_NUM" | sed '/ /s//0/g'`

	    #echo "  L1488: PGN_4NUM=$PGN_4NUM; PGN_NUM=$PGN_NUM"
	    
        elif [[ "$PGN_NUM" -gt 9999 ]]; then
	  PGN_4NUM="0001"; PGN_NUM=1;
	  ## 每个对局结束后,或者在退出程序前,需要把 PGN_NUM 的数值(即序号)
	  #  写入配置文件. 这样下次运行程序,会接着上次的编号. 
        else
	  PGN_4NUM="$PGN_NUM" ;
        fi
	
  ## T1589: DATE_UNIX 及 _mk_pgn_datetime 取值, 用于 PGN 文件名

	if [  "$PGN_NAME_STYLE" = 1 ]; then
    # ------------------  	  
    DATE_UNIX=`date +%s`
    _mk_pgn_datetime
    # ------------------ 

    PGN_FILE="$PGN_DIR/${PGN_4DATE}${PGN_4NUM}.pgn"
    if [ -s "$PGN_FILE" ]; then
	## 如果 .pgn_index 索引文件被删除, 或者无法写入(序号不能更新),
	## 或者同一电脑上多个 cchess 同时运行, 可能导致生成的文件名重名.
	## 这种情况下,需要加上额外的 时分秒($DATE_06HMS), 随机码($STR_TMP),
	## 来解决重名的问题.
	#
	## 注: 6位时分秒($DATE_06HMS), 10位随机码($STR_TMP)在
	#  _mk_pgn_datetime ()
	## 中已经生成了. 为了最大限度避免雷同,这里再更新一次随机码.

	STR_TMP=`mktemp -u | cut -d'.' -f2`
	
      PGN_FILE="$PGN_DIR/${PGN_4DATE}${PGN_4NUM}_${DATE_06HMS}_${STR_TMP}.pgn"
    fi
    
      #      PGN_FILE="$PGN_DIR/$PGN_UUID.pgn"
      
      elif [  "$PGN_NAME_STYLE" = 2 ]; then
	  ## PGN 命名规则2(旧方案): 按 年月日-时分秒 定义,方便排序查找
          PGN_FILE="$PGN_DIR/`date +%Y-%m%d_%H%M-%S`.pgn"
	  
      else
  ## 见 T1629: DATE_UNIX 及 _mk_pgn_datetime 取值, 用于 PGN_UUID 索引
    # ------------------  	  
    DATE_UNIX=`date +%s`
    _mk_pgn_datetime
    # ------------------    
	  ## PGN 命名规则3(新方案, 带有明显的序号, 方便查找):
	  # 按 年月日-时分秒 定义,方便排序和查找
    PGN_FILE="$PGN_DIR/${PGN_4DATE}${PGN_4NUM}_`date +%Y-%m%d_%H%M-%S`.pgn"
    
    #PGN_FILE="$PGN_DIR/${PGN_4DATE}${PGN_4NUM}_`date +%Y-%m%d_%H%M-%S`_${STR_TMP}.pgn"
    
      fi



    
      ## 更新胜负结果 Result 标签, 以及其它标签,
 
    sed -i "/^\[Result /c[Result \"$STR_RESULT\"]" "$PGN_HEAD"

    ### 及时更新 PGN_NUM 棋局索引序号数字(4位),减少程序意外退出的序号数值
    ## 未保存导致的重号和序号回退
    
    #let "PGN_NUM += 1"    
    #echo "$PGN_NUM" > "$PGN_INDEX"

    ###

    ### T1629: 
    ### 更新 PGN 文件头中的 [Index ""] 标签的 PGN_UUID 索引数据,
    ##  用来区分和定位同一 PGN 文件中的多个对局
    # ------------------    
    DATE_UNIX=`date +%s`
    _mk_pgn_datetime
    # ------------------
    
### 生成10位随机字符串, 用作 PGN_UUID 的附加码, 防止重号
STR_TMP=`mktemp -u | cut -d'.' -f2`

    PGN_UUID="${PGN_4DATE}-${DATE_06HMS}-${PGN_4NUM}-${STR_TMP}"
    sed -i "/^\[Index /c[Index \"$PGN_UUID\"]" "$PGN_HEAD"   
    
    ### T1527: 
         #DEBUG=1
    if [  "$DEBUG" = 1 ]; then
        echo "  L1524: PGN_NUM=$PGN_NUM; PGN_UUID=$PGN_UUID"
	#sleep 10;
    fi
      
      cat "$PGN_HEAD" >> "$PGN_FILE"
    

      ## 更新/写入 FEN 棋局数据串, 如
#[FEN "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1"]
      _mk_default_fen >> "$PGN_FILE"

      ## 此时 PGN_BODY 临时文件中, 已经包含对局胜负结果, 以及结果的文字说明,
      #  如: {红胜}
      cat "$PGN_BODY" >> "$PGN_FILE"
      #echo -e "${STR_RESULT} ${TEXT_RESULT}\n" >> "$PGN_FILE"

      ### 如此时 PGN 文件已经保存成功. PGN_UUID 里的 PGN_NUM 序号计数应 +1,
      #   并及时写入新的序号数值
      #echo "  L1570: PGN_NUM=$PGN_NUM"
      
      let "PGN_NUM += 1"

      #echo "  L1572: PGN_NUM=$PGN_NUM"      
      ## 注意: 可以使用 echo -n 参数(即不换行)；也可以不带 -n 参数(带换行符)
      echo -n "$PGN_NUM" > "$PGN_INDEX"

      #

      break; #T719: 保存/导出PGN/FEN文件后,退出程序


      
  #tput rc; tput ed; continue; 
  ;;

  //++)## 注: 功能暂不能正常使用
      # 进入评论模式
      tput rc; tput ed;
      #continue;
      
      #
      echo "  切换到 [评论模式]"
      echo -e "  (返回 [走棋模式]: 输入评论文字后(可以换行), 先按回车键\
,再同时按 Ctrl + C)"      

      ## usage: trap 'cmd' HUP INT QUIT TERM EXIT
      PGN_DESC=`mktemp`
      
      ## 注: 输入内容后 (可以多次换行), 再多按一次回车键换行,
      #  最后再按 Ctrl + C 退出评论模式,
      #     返回走棋模式

      trap "{

      ## 注1: trap 里面的程序,只在捕获到信号退出时,才会开始执行
      ## 注2: trap的花括号里面, 不要用双引号,会提示: 错误的 SIG???
       
         tput rc; tput ed;
         #continue;

             }" SIGINT
      
      echo -e " {" > "$PGN_DESC"
      cat >> "$PGN_DESC"

      #
      echo -e "}" >> "$PGN_DESC"
      cat "$PGN_DESC" >> "$PGN_BODY"
        tput rc; tput ed;
      echo -e '\n   进入 [走棋模式]'    
      #tput rc; tput ed;
      continue; 
  ;;

   
	### 其它无效的棋子或者走法，清除错误的输入后，等待重新输入
#	[^1-7]* | [1-7][^1-9+-.abcdeABCDE]* | *)
 [hH][eE][lL][pP])
     _sample_wxf_00;
     #tput rc; tput ed;
     continue; 
  ;;

  [mM][oO][rR][eE])
     _sample_wxf_extra;
     #tput rc; tput ed;
     continue; 
     ;;
  
 *)
  tput rc; tput ed; continue; 
    ;;
esac

## T1640:
## 以后功能扩展后, 可能其它的操作代码,也需要随时更新索引序号文件
## PGN_INDEX, FEN_INDEX

# let "PGN_NUM += 1"
    #echo -n "$PGN_NUM" > "$PGN_INDEX"

done

#

### 显示生成的 PGN 对局/棋谱文件 (主要用于调试)
### TAG1714: PGN_VIEWMODE:
#  =0: 只显示最前和最后各10行(不带行号)；
#  =1: 与=0类似, 但同时显示行号(用grep -n 实现)
#PGN_VIEWMODE=1

if [ "$SHOW_PGN" = 1 ]; then
    ## 如果是在图形界面, 用编辑器打开 PGN 文件.
    #  如果是在控制台 (tty1-tty6), 只显示最前面和最后面的部分行数
    #  (显示的总行数之和小于或者等于控制台最大能显示的行数)
    if [ "$DISPLAY" != '' ]; then
	xdg-open "$PGN_FILE" &
    else
	echo "* 保存到 PGN 文件: $PGN_FILE"
	#sleep 3
	#echo " ----------------- "
	if [ "$PGN_VIEWMODE" = 0 ]; then
	  head "$PGN_FILE"; echo; tail "$PGN_FILE"
	else
	    ### 至少要保留两行备用:
	    # 屏幕最顶上1行显示文件名, 最后1行留给用户输入新指令
	    MAX_LINES=`tput lines`
	    let "MAX_LINES = MAX_LINES - 1"
	    
	    FILE_LINES=`wc -l "$PGN_FILE" | cut -d' ' -f1`

	    if [[ "$FILE_LINES" -lt "$MAX_LINES" ]]; then
		grep -n . --color=auto "$PGN_FILE"
	    else
		let "SHOW_HEAD_LINES = `tput lines` / 2 - 1" 
		let "SHOW_TAIL_LINES = `tput lines` / 2 - 1" 
	    
	    # grep -n . --color=auto | head -10
	    head -n "$SHOW_HEAD_LINES" "$PGN_FILE" | grep -n . --color=auto
	    #echo;
	    grep -n . --color=auto "$PGN_FILE" | tail -n "$SHOW_TAIL_LINES";	    
	    fi	    

	fi
	
 
	fi

  fi

  ## T1231: 


### 暂停1秒 !!! 非常重要!!!
## 如果在图形界面, 以 cchess.desktop 的快捷方式运行, 用来查看生成的 PGN 文件.
## 如果不作短暂停顿, PGN 文件还没来得及打开, 整个进程就被提前关闭退出了.

case "$DISPLAY" in
    :[0-9].[0-9]*)
    sleep 1 ;;
esac

exit 0;

